---
phase: 19-admin-bug-fixes
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - js/admin.js
autonomous: true
requirements:
  - ADM-01
  - ADM-02
  - ADM-03
  - ADM-05
  - ADM-10

must_haves:
  truths:
    - "approveTextSubmission uses String() coercion so numeric IDs match string IDs from the cached array"
    - "rejectTextSubmission deletes texts by specific ID stored during approval, not by title+author match"
    - "createPrompt button always re-enables after submission, even when the insert throws"
    - "loadMoments shows a loading spinner before fetch completes and an empty state when there are zero moments"
    - "fetchData actually uses the order parameter instead of hardcoding created_at.desc"
  artifacts:
    - path: "js/admin.js"
      provides: "Fixed submission ID handling, prompt button finally block, moments loading state, fetchData order usage"
      contains: "String("
  key_links:
    - from: "js/admin.js"
      to: "textSubmissions array"
      via: "String() coercion in find callback"
      pattern: "String\\("
    - from: "js/admin.js"
      to: "createPrompt button"
      via: "finally block re-enables button"
      pattern: "finally"
---

<objective>
Fix five JS logic bugs in admin.js: text submission ID comparison, rejection deletion by ID, prompt button reset, moments loading state, and fetchData order parameter.

Purpose: These bugs cause silent failures (ID mismatches), permanent UI lockout (button stuck disabled), confusing UX (no loading state), and dead code (unused order parameter).
Output: Correct ID handling, resilient button state, loading UX for moments, and working fetchData order support.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@js/admin.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Fix text submission ID coercion and rejection deletion</name>
  <files>js/admin.js</files>
  <action>
**ADM-01 -- String coercion for ID comparison in approveTextSubmission and rejectTextSubmission:**

The `approveTextSubmission` function (around line 950) does:
```javascript
const submission = textSubmissions.find(s => s.id === id);
```

The `id` parameter comes from an inline onclick `approveTextSubmission('${sub.id}')` which passes a string. But `sub.id` in the Supabase data might be a number (integer primary key). If `s.id` is `42` (number) and `id` is `"42"` (string), `===` returns false and the submission is "not found".

Fix both `approveTextSubmission` and `rejectTextSubmission` to use `String()` coercion:

In `approveTextSubmission` (line ~953):
```javascript
const submission = textSubmissions.find(s => String(s.id) === String(id));
```

In `rejectTextSubmission` (line ~986):
```javascript
const submission = textSubmissions.find(s => String(s.id) === String(id));
```

**ADM-02 -- Delete texts by specific ID, not by title+author match:**

In `rejectTextSubmission` (around line 1002-1007), when unapproving a previously approved submission, the code deletes from the `texts` table by matching both `title` and `author`:
```javascript
const { error: deleteError } = await getClient()
    .from('texts')
    .delete()
    .eq('title', submission.title)
    .eq('author', submission.author);
```

This is fragile — if two texts share the same title and author, both get deleted. The approval step should store the ID of the published text so we can delete by ID.

Fix approach: During approval in `approveTextSubmission`, after the insert, store the published text's ID on the submission record. Then during rejection, delete by that stored ID.

Step 1 - In `approveTextSubmission`, change the insert to return the new text's ID, and store it on the submission:
```javascript
// Publish to texts table so it appears in the Reading Room
const { data: insertedText, error: insertError } = await getClient()
    .from('texts')
    .insert({
        title: submission.title,
        author: submission.author,
        content: submission.content,
        category: submission.category || 'other',
        source: submission.source || null
    })
    .select('id')
    .single();

if (insertError) {
    console.error('Failed to publish to texts table:', insertError);
    alert('Approved but failed to publish to Reading Room: ' + insertError.message);
} else if (insertedText) {
    // Store the published text ID on the submission for later deletion
    await getClient()
        .from('text_submissions')
        .update({ published_text_id: insertedText.id })
        .eq('id', id);
}
```

Note: The `published_text_id` column may not exist in the schema. If so, use a simpler approach — look up the text by title+author+content (more specific match) or just by ID if we stored it. Since we can't assume the schema has this column, use the safer fallback: look up the matching text's ID during rejection, but with a more specific match. Actually, the safest approach without schema changes is:

Step 1 (revised) - In `approveTextSubmission`, capture the inserted text's ID and store it in the local submission object:
```javascript
const { data: insertedText, error: insertError } = await getClient()
    .from('texts')
    .insert({
        title: submission.title,
        author: submission.author,
        content: submission.content,
        category: submission.category || 'other',
        source: submission.source || null
    })
    .select('id')
    .single();

if (insertError) {
    console.error('Failed to publish to texts table:', insertError);
    alert('Approved but failed to publish to Reading Room: ' + insertError.message);
} else if (insertedText) {
    submission._published_text_id = insertedText.id;
}
```

Step 2 - In `rejectTextSubmission`, delete by specific ID if available, fall back to title+author:
```javascript
if (wasApproved && submission) {
    let deleteError;
    if (submission._published_text_id) {
        // Delete by specific ID (reliable)
        const result = await getClient()
            .from('texts')
            .delete()
            .eq('id', submission._published_text_id);
        deleteError = result.error;
    } else {
        // Fallback: look up by title+author, limit 1
        const { data: matchingTexts } = await getClient()
            .from('texts')
            .select('id')
            .eq('title', submission.title)
            .eq('author', submission.author)
            .limit(1);

        if (matchingTexts && matchingTexts.length > 0) {
            const result = await getClient()
                .from('texts')
                .delete()
                .eq('id', matchingTexts[0].id);
            deleteError = result.error;
        }
    }

    if (deleteError) {
        console.error('Failed to remove from texts table:', deleteError);
        alert('Rejected but failed to remove from Reading Room: ' + deleteError.message);
    }
}
```

This ensures only one specific text record is deleted, never accidentally deleting multiple texts with the same title and author.
  </action>
  <verify>
    <automated>cd C:/Users/mmcge/the-commons && grep -q "String(s.id) === String(id)" js/admin.js && grep -q "_published_text_id" js/admin.js && echo "ADM-01 and ADM-02 OK"</automated>
  </verify>
  <done>approveTextSubmission and rejectTextSubmission both use String() coercion for ID comparison. Rejection deletes by specific text ID when available, with a limit(1) fallback.</done>
</task>

<task type="auto">
  <name>Task 2: Fix createPrompt button reset, moments loading state, and fetchData order</name>
  <files>js/admin.js</files>
  <action>
**ADM-03 -- createPrompt button finally block:**

The current `createPrompt` function (around line 1042-1084) has the button reset AFTER the try/catch block (lines 1082-1083):
```javascript
    } catch (error) {
        alert('Failed to create prompt: ' + error.message);
    }

    btn.disabled = false;
    btn.textContent = 'Create & Activate';
```

While this currently works (the reset code runs after both success and failure), it's fragile — any future refactoring that adds an early return or moves code could break it. Per the CONTEXT.md decision, wrap in a `finally` block:

```javascript
    } catch (error) {
        alert('Failed to create prompt: ' + error.message);
    } finally {
        btn.disabled = false;
        btn.textContent = 'Create & Activate';
    }
```

Remove the two lines that were previously after the try/catch block (the duplicate btn.disabled and btn.textContent lines).

**ADM-05 -- loadMoments loading state:**

The current `loadMoments` function (around line 1154) jumps straight into the fetch with no loading indicator. Per CONTEXT.md, add a loading state to the moments tab only, plus an empty state message.

Change `loadMoments` to:
```javascript
async function loadMoments() {
    const container = document.getElementById('moments-list');
    container.innerHTML = '<div class="loading"><div class="loading__spinner"></div>Loading moments...</div>';

    try {
        const { data, error } = await getClient()
            .from('moments')
            .select('*')
            .order('event_date', { ascending: false });

        if (error) throw error;
        moments = data || [];
        renderMoments();
        updateTabCount('moments', moments.length);
    } catch (error) {
        console.error('Error loading moments:', error);
        container.innerHTML =
            '<p class="admin-empty">Failed to load moments</p>';
    }
}
```

Also update `renderMoments` to show an explicit "No moments yet" empty state:
```javascript
function renderMoments() {
    const container = document.getElementById('moments-list');
    if (!container) return;

    if (!moments.length) {
        container.innerHTML = '<div class="admin-empty">No moments yet</div>';
        return;
    }
    // ... rest of render unchanged
}
```

Change the empty state text from "No moments found" to "No moments yet" per the CONTEXT.md decision.

**ADM-10 -- fetchData order parameter actually used:**

The `fetchData` function (lines 119-132) accepts an `order` parameter but ignores it:
```javascript
async function fetchData(table, select = '*', order = 'created_at.desc') {
    try {
        const { data, error } = await getClient()
            .from(table)
            .select(select)
            .order('created_at', { ascending: false }); // HARDCODED!
```

Fix by parsing the `order` parameter:
```javascript
async function fetchData(table, select = '*', order = 'created_at.desc') {
    try {
        const [orderCol, orderDir] = order.split('.');
        const ascending = orderDir === 'asc';

        const { data, error } = await getClient()
            .from(table)
            .select(select)
            .order(orderCol, { ascending });
```

This parses the dot-separated `column.direction` format that's already used as the default parameter value. All existing callers use the default, so behavior is unchanged but the parameter now works correctly for any future callers.
  </action>
  <verify>
    <automated>cd C:/Users/mmcge/the-commons && grep -A2 "alert.*Failed to create prompt" js/admin.js | grep -q "finally" && grep -q "Loading moments" js/admin.js && grep -q "orderCol" js/admin.js && echo "ADM-03 ADM-05 ADM-10 OK"</automated>
  </verify>
  <done>createPrompt button reset is in a finally block. loadMoments shows loading spinner before fetch and "No moments yet" on empty results. fetchData parses and uses the order parameter.</done>
</task>

</tasks>

<verification>
- Open admin.html in browser while logged in as admin
- Text Submissions tab: Approve and reject actions should find submissions correctly (no "Submission not found" errors)
- Prompts tab: Create a prompt, then force an error (e.g., disconnect network) -- button should still re-enable
- News/Moments tab: On initial load, a loading spinner should appear briefly before moments render
- Check console: no errors from any tab loading
</verification>

<success_criteria>
- String() coercion used in both approveTextSubmission and rejectTextSubmission find calls
- rejectTextSubmission deletes by specific ID (not broad title+author match)
- createPrompt button reset is inside a finally block
- loadMoments shows loading indicator before fetch
- fetchData parses order parameter into column and direction
</success_criteria>

<output>
After completion, create `.planning/phases/19-admin-bug-fixes/19-01-SUMMARY.md`
</output>
