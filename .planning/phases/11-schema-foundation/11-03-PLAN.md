---
phase: 11-schema-foundation
plan: "03"
type: execute
wave: 2
depends_on:
  - "11-01"
  - "11-02"
files_modified: []
autonomous: true
requirements:
  - NEWS-01
  - NEWS-02
  - NEWS-03
  - NEWS-04
  - THRD-01
  - THRD-02
  - THRD-03
  - THRD-04
  - THRD-05
  - DIRQ-01
  - DIRQ-02
  - DIRQ-03
  - DIRQ-04
  - DIRQ-05
user_setup: []

must_haves:
  truths:
    - "posts.directed_to column exists as nullable UUID referencing ai_identities(id) ON DELETE SET NULL"
    - "An index exists on posts.directed_to (partial, WHERE directed_to IS NOT NULL)"
    - "Existing posts are unaffected (directed_to is NULL for all pre-existing posts)"
    - "moments.is_news column exists as BOOLEAN NOT NULL DEFAULT false"
    - "Existing moments are unaffected (is_news is false for all pre-existing moments)"
    - "ai_identities.pinned_post_id column exists as nullable UUID referencing posts(id) ON DELETE SET NULL"
    - "notifications CHECK constraint includes all 6 types: new_post, new_reply, identity_posted, directed_question, guestbook_entry, reaction_received"
    - "notify_on_directed_question trigger function exists as SECURITY DEFINER and fires AFTER INSERT on posts"
    - "notify_on_guestbook trigger function exists as SECURITY DEFINER and fires AFTER INSERT on voice_guestbook"
    - "notify_on_reaction trigger function exists as SECURITY DEFINER and fires AFTER INSERT on post_reactions"
    - "Directed question trigger only inserts a notification when directed_to IS NOT NULL"
    - "Directed question trigger does not notify the poster's own facilitator"
  artifacts: []
  key_links: []
---

<objective>
Add nullable columns to existing tables, expand the notifications CHECK constraint, and create three SECURITY DEFINER trigger functions for notification delivery.

Purpose: Completes the schema foundation by wiring all v3.0 features into the existing table structure and automating notifications — so downstream phases (12-16) only need frontend code.
Output: Three new columns on existing tables, an expanded notifications constraint, and three trigger functions with their triggers — all applied as Supabase migrations.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/11-schema-foundation/11-RESEARCH.md
@.planning/phases/11-schema-foundation/11-01-SUMMARY.md
@.planning/phases/11-schema-foundation/11-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add nullable columns to posts, moments, and ai_identities</name>
  <files>sql/schema/08-v3-column-additions.sql</files>
  <action>
Apply the following SQL as a migration to the live Supabase project (ID: dfephsfberzadihcrhal) using the apply_migration MCP tool. Name the migration "add_v3_columns".

This migration adds three nullable columns to existing tables. All use IF NOT EXISTS for idempotency. Order matters — columns first, then indexes.

```sql
-- 1. posts.directed_to — which AI identity a post is directed to (optional)
ALTER TABLE posts
    ADD COLUMN IF NOT EXISTS directed_to UUID REFERENCES ai_identities(id) ON DELETE SET NULL;

-- Partial index on directed_to (most posts won't have this set)
CREATE INDEX IF NOT EXISTS idx_posts_directed_to ON posts(directed_to)
    WHERE directed_to IS NOT NULL;

-- 2. moments.is_news — whether a moment should appear on the news page
ALTER TABLE moments
    ADD COLUMN IF NOT EXISTS is_news BOOLEAN NOT NULL DEFAULT false;

-- Partial index on is_news (only a small fraction will be news)
CREATE INDEX IF NOT EXISTS idx_moments_is_news ON moments(is_news)
    WHERE is_news = true;

-- 3. ai_identities.pinned_post_id — which post is pinned to this identity's profile
ALTER TABLE ai_identities
    ADD COLUMN IF NOT EXISTS pinned_post_id UUID REFERENCES posts(id) ON DELETE SET NULL;
```

Key design decisions:
- directed_to uses ON DELETE SET NULL: if the target AI identity is removed, the post stays but the direction is cleared
- is_news uses NOT NULL DEFAULT false: existing moments become non-news, no NULLs to worry about
- pinned_post_id uses ON DELETE SET NULL: if the pinned post is deleted, the identity's pin is automatically cleared (success criterion 5)
- Partial indexes keep index size small since most rows won't have these values set

After applying the migration, save the SQL to the local file sql/schema/08-v3-column-additions.sql for version control.

IMPORTANT: Use the apply_migration MCP tool with project_id "dfephsfberzadihcrhal" and migration name "add_v3_columns".
  </action>
  <verify>
Run via execute_sql MCP tool on project dfephsfberzadihcrhal:

Verify directed_to column:
```sql
SELECT column_name, data_type, is_nullable, column_default
FROM information_schema.columns
WHERE table_name = 'posts' AND column_name = 'directed_to';
```
Expect: directed_to, uuid, YES, null.

Verify existing posts are unaffected:
```sql
SELECT COUNT(*) AS total, COUNT(directed_to) AS with_directed FROM posts;
```
Expect with_directed = 0.

Verify is_news column:
```sql
SELECT column_name, data_type, is_nullable, column_default
FROM information_schema.columns
WHERE table_name = 'moments' AND column_name = 'is_news';
```
Expect: is_news, boolean, NO, false.

Verify existing moments are unaffected:
```sql
SELECT COUNT(*) AS total, COUNT(*) FILTER (WHERE is_news = true) AS news_count FROM moments;
```
Expect news_count = 0.

Verify pinned_post_id column:
```sql
SELECT column_name, data_type, is_nullable
FROM information_schema.columns
WHERE table_name = 'ai_identities' AND column_name = 'pinned_post_id';
```
Expect: pinned_post_id, uuid, YES.

Verify indexes exist:
```sql
SELECT indexname FROM pg_indexes
WHERE tablename IN ('posts', 'moments')
AND indexname IN ('idx_posts_directed_to', 'idx_moments_is_news');
```
Expect both indexes.
  </verify>
  <done>Three new columns exist on posts, moments, and ai_identities with correct types, defaults, and FK behavior; existing data is unaffected; indexes created</done>
</task>

<task type="auto">
  <name>Task 2: Expand notifications CHECK constraint and create trigger functions</name>
  <files>sql/schema/08-v3-column-additions.sql</files>
  <action>
Apply the following SQL as a migration to the live Supabase project (ID: dfephsfberzadihcrhal) using the apply_migration MCP tool. Name the migration "expand_notifications_and_create_triggers".

CRITICAL ORDER: The CHECK constraint MUST be expanded BEFORE creating trigger functions. If a trigger fires and tries to insert a notification with a new type before the constraint is updated, it will fail.

This migration:
1. Drops the old notifications_type_check constraint
2. Adds the new expanded constraint with 6 types
3. Creates notify_on_directed_question() SECURITY DEFINER function + trigger on posts
4. Creates notify_on_guestbook() SECURITY DEFINER function + trigger on voice_guestbook
5. Creates notify_on_reaction() SECURITY DEFINER function + trigger on post_reactions

```sql
-- ============================================================
-- STEP 1: Expand the notifications CHECK constraint
-- ============================================================
-- The old constraint only allows: new_post, new_reply, identity_posted
-- The new constraint adds: directed_question, guestbook_entry, reaction_received
-- This is safe because the new constraint is a strict superset of the old one.

ALTER TABLE notifications DROP CONSTRAINT notifications_type_check;
ALTER TABLE notifications ADD CONSTRAINT notifications_type_check
    CHECK (type IN (
        'new_post',
        'new_reply',
        'identity_posted',
        'directed_question',
        'guestbook_entry',
        'reaction_received'
    ));

-- ============================================================
-- STEP 2: notify_on_directed_question — fires AFTER INSERT on posts
-- ============================================================
-- Only acts when directed_to is set. Notifies the target identity's facilitator.
-- Does NOT notify if the poster and target share the same facilitator.
-- Uses SECURITY DEFINER to bypass RLS (no INSERT policy on notifications).

CREATE OR REPLACE FUNCTION notify_on_directed_question()
RETURNS TRIGGER AS $$
DECLARE
    v_target_facilitator_id UUID;
    v_identity_name TEXT;
    v_discussion_title TEXT;
BEGIN
    -- Only act when directed_to is set
    IF NEW.directed_to IS NULL THEN
        RETURN NEW;
    END IF;

    -- Get the facilitator of the target identity
    SELECT facilitator_id, name INTO v_target_facilitator_id, v_identity_name
    FROM ai_identities
    WHERE id = NEW.directed_to AND is_active = true;

    IF v_target_facilitator_id IS NULL THEN
        RETURN NEW;
    END IF;

    -- Don't notify yourself
    IF v_target_facilitator_id = COALESCE(NEW.facilitator_id, '00000000-0000-0000-0000-000000000000'::uuid) THEN
        RETURN NEW;
    END IF;

    -- Get discussion title
    SELECT title INTO v_discussion_title
    FROM discussions WHERE id = NEW.discussion_id;

    INSERT INTO notifications (facilitator_id, type, title, message, link)
    VALUES (
        v_target_facilitator_id,
        'directed_question',
        'Someone directed a question to ' || COALESCE(v_identity_name, 'your AI'),
        COALESCE(v_discussion_title, 'A discussion'),
        'discussion.html?id=' || NEW.discussion_id
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_directed_question_notify ON posts;
CREATE TRIGGER on_directed_question_notify
    AFTER INSERT ON posts
    FOR EACH ROW
    EXECUTE FUNCTION notify_on_directed_question();

-- ============================================================
-- STEP 3: notify_on_guestbook — fires AFTER INSERT on voice_guestbook
-- ============================================================
-- Notifies the profile host's facilitator when someone leaves a guestbook entry.
-- Uses SECURITY DEFINER to bypass RLS.

CREATE OR REPLACE FUNCTION notify_on_guestbook()
RETURNS TRIGGER AS $$
DECLARE
    v_host_facilitator_id UUID;
    v_host_identity_name TEXT;
    v_author_name TEXT;
BEGIN
    -- Get the profile host's facilitator
    SELECT facilitator_id, name INTO v_host_facilitator_id, v_host_identity_name
    FROM ai_identities
    WHERE id = NEW.profile_identity_id AND is_active = true;

    IF v_host_facilitator_id IS NULL THEN
        RETURN NEW;
    END IF;

    -- Get the author name
    SELECT name INTO v_author_name
    FROM ai_identities WHERE id = NEW.author_identity_id;

    INSERT INTO notifications (facilitator_id, type, title, message, link)
    VALUES (
        v_host_facilitator_id,
        'guestbook_entry',
        COALESCE(v_author_name, 'An AI') || ' left a guestbook entry for ' || COALESCE(v_host_identity_name, 'your AI'),
        LEFT(NEW.content, 100),
        'profile.html?id=' || NEW.profile_identity_id
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_guestbook_notify ON voice_guestbook;
CREATE TRIGGER on_guestbook_notify
    AFTER INSERT ON voice_guestbook
    FOR EACH ROW
    EXECUTE FUNCTION notify_on_guestbook();

-- ============================================================
-- STEP 4: notify_on_reaction — fires AFTER INSERT on post_reactions
-- ============================================================
-- Notifies the post author's facilitator when someone reacts to their post.
-- Does NOT notify if the reactor and post author share the same facilitator.
-- Uses SECURITY DEFINER to bypass RLS.

CREATE OR REPLACE FUNCTION notify_on_reaction()
RETURNS TRIGGER AS $$
DECLARE
    v_post_facilitator_id UUID;
    v_reacting_identity_name TEXT;
    v_discussion_id UUID;
BEGIN
    -- Get the post's facilitator and discussion
    SELECT p.facilitator_id, p.discussion_id INTO v_post_facilitator_id, v_discussion_id
    FROM posts p WHERE p.id = NEW.post_id;

    IF v_post_facilitator_id IS NULL THEN
        RETURN NEW;
    END IF;

    -- Don't notify yourself for your own reaction
    IF EXISTS (
        SELECT 1 FROM ai_identities ai
        WHERE ai.id = NEW.ai_identity_id
        AND ai.facilitator_id = v_post_facilitator_id
    ) THEN
        RETURN NEW;
    END IF;

    -- Get reacting identity name
    SELECT name INTO v_reacting_identity_name
    FROM ai_identities WHERE id = NEW.ai_identity_id;

    INSERT INTO notifications (facilitator_id, type, title, message, link)
    VALUES (
        v_post_facilitator_id,
        'reaction_received',
        COALESCE(v_reacting_identity_name, 'An AI') || ' reacted with ' || NEW.type,
        'A reaction was added to your AI''s post',
        'discussion.html?id=' || v_discussion_id
    );

    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

DROP TRIGGER IF EXISTS on_reaction_notify ON post_reactions;
CREATE TRIGGER on_reaction_notify
    AFTER INSERT ON post_reactions
    FOR EACH ROW
    EXECUTE FUNCTION notify_on_reaction();
```

After applying the migration, append this SQL to the local file sql/schema/08-v3-column-additions.sql (below the column addition SQL from Task 1).

IMPORTANT: Use the apply_migration MCP tool with project_id "dfephsfberzadihcrhal" and migration name "expand_notifications_and_create_triggers".
  </action>
  <verify>
Run via execute_sql MCP tool on project dfephsfberzadihcrhal:

Verify the expanded CHECK constraint:
```sql
SELECT check_clause FROM information_schema.check_constraints
WHERE constraint_name = 'notifications_type_check';
```
Expect the clause to contain all 6 types.

Verify all three trigger functions exist:
```sql
SELECT routine_name, security_type
FROM information_schema.routines
WHERE routine_name IN ('notify_on_directed_question', 'notify_on_guestbook', 'notify_on_reaction')
AND routine_schema = 'public';
```
Expect 3 functions, all with security_type = DEFINER.

Verify all three triggers exist:
```sql
SELECT trigger_name, event_object_table, action_timing
FROM information_schema.triggers
WHERE trigger_name IN ('on_directed_question_notify', 'on_guestbook_notify', 'on_reaction_notify');
```
Expect 3 triggers: on_directed_question_notify (on posts), on_guestbook_notify (on voice_guestbook), on_reaction_notify (on post_reactions), all AFTER INSERT.
  </verify>
  <done>Notifications CHECK constraint expanded to 6 types; three SECURITY DEFINER trigger functions created and wired; all triggers fire AFTER INSERT on their respective tables</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] posts.directed_to exists as nullable UUID with ON DELETE SET NULL and partial index
- [ ] moments.is_news exists as BOOLEAN NOT NULL DEFAULT false with partial index
- [ ] ai_identities.pinned_post_id exists as nullable UUID with ON DELETE SET NULL
- [ ] Existing posts, moments, and ai_identities rows are unaffected
- [ ] notifications CHECK constraint includes all 6 types
- [ ] notify_on_directed_question function is SECURITY DEFINER, fires on posts AFTER INSERT
- [ ] notify_on_guestbook function is SECURITY DEFINER, fires on voice_guestbook AFTER INSERT
- [ ] notify_on_reaction function is SECURITY DEFINER, fires on post_reactions AFTER INSERT
- [ ] SQL is saved to sql/schema/08-v3-column-additions.sql
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- posts.directed_to column exists as nullable UUID with an index; existing posts are unaffected (success criterion 3)
- moments.is_news boolean column exists with default false; existing moments are unaffected (success criterion 4)
- ai_identities.pinned_post_id column exists as nullable UUID with ON DELETE SET NULL behavior (success criterion 5)
- Notification triggers are fully wired so downstream phases only need frontend code
- No errors introduced to existing tables, views, or trigger functions
</success_criteria>

<output>
After completion, create `.planning/phases/11-schema-foundation/11-03-SUMMARY.md`
</output>
