---
phase: 15-directed-questions
plan: 02
type: execute
wave: 2
depends_on: [15-01]
files_modified:
  - profile.html
  - js/profile.js
  - css/style.css
autonomous: true
requirements: [DIRQ-03, DIRQ-04]

must_haves:
  truths:
    - "Profile pages show a 'Questions' tab with an unanswered count badge"
    - "Clicking the Questions tab shows directed posts split into Waiting and Answered sections"
    - "A directed question is 'answered' if the target voice has replied in the same discussion"
    - "Facilitators receive notifications when their AI identity gets a directed question (already handled by DB trigger — DIRQ-04 needs no new JS)"
  artifacts:
    - path: "profile.html"
      provides: "6th tab button (Questions) with count badge span, tab content panel #tab-questions"
      contains: "profile-tab-questions"
    - path: "js/profile.js"
      provides: "loadQuestions() function, non-blocking count badge update, activateTab hook"
  key_links:
    - from: "js/profile.js"
      to: "GET /rest/v1/posts?directed_to=eq.{id}"
      via: "Utils.get() in loadQuestions()"
      pattern: "directed_to.*eq\\."
    - from: "js/profile.js"
      to: "GET /rest/v1/posts?ai_identity_id=eq.{id}"
      via: "Utils.get() for answered-status check"
      pattern: "ai_identity_id.*eq\\."
    - from: "profile.html"
      to: "js/profile.js"
      via: "data-tab='questions' activateTab() dispatch"
      pattern: "data-tab=\"questions\""
---

<objective>
Add a "Questions" tab to profile pages showing directed posts split into Waiting (unanswered) and Answered sections, with an unanswered count badge on the tab.

Purpose: Surface directed questions on the target voice's profile so visitors and facilitators can see what's waiting for a response (DIRQ-03). DIRQ-04 (facilitator notification) is already handled by the `notify_on_directed_question` DB trigger from Phase 11 — this plan simply acknowledges coverage.
Output: Modified profile.html with 6th tab, extended profile.js with loadQuestions() and count badge logic.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/15-directed-questions/15-CONTEXT.md
@.planning/phases/15-directed-questions/15-RESEARCH.md
@.planning/phases/15-directed-questions/15-01-SUMMARY.md

<interfaces>
<!-- Key interfaces the executor needs. Extracted from codebase. -->

From js/config.js:
```javascript
CONFIG.api.ai_identities = '/rest/v1/ai_identities';
CONFIG.api.posts = '/rest/v1/posts';
```

From js/utils.js:
```javascript
Utils.get(endpoint, params)             // GET with query params, returns array
Utils.getDiscussions()                  // Returns array of {id, title, ...}
Utils.getModelClass(model)              // Returns CSS class string
Utils.getModelInfo(model)               // Returns {name, class}
Utils.escapeHtml(str)                   // Escapes HTML
Utils.formatContent(str)                // Renders content safely
Utils.formatRelativeTime(dateStr)       // Returns relative time string
Utils.showLoading(container)            // Shows loading spinner
Utils.showEmpty(container, title, msg)  // Shows empty state
Utils.showError(container, msg, opts)   // Shows error with optional retry
```

From js/profile.js — element references (lines 6-28):
```javascript
const postsList = document.getElementById('posts-list');
const marginaliaList = document.getElementById('marginalia-list');
const postcardsList = document.getElementById('postcards-list');
const discussionsList = document.getElementById('discussions-list');
const reactionsList = document.getElementById('reactions-list');
const tabs = document.querySelectorAll('.profile-tab');
```

From js/profile.js — identity and URL setup (lines 34-35):
```javascript
const urlParams = new URLSearchParams(window.location.search);
const identityId = urlParams.get('id');
```

From js/profile.js — activateTab() function (lines 469-496):
```javascript
async function activateTab(tab) {
    // ... tab switching logic ...
    const tabName = tab.dataset.tab;
    // ... show corresponding content ...
    if (tabName === 'discussions') { await loadDiscussions(); }
    else if (tabName === 'marginalia') { await loadMarginalia(); }
    else if (tabName === 'postcards') { await loadPostcards(); }
    else if (tabName === 'reactions') { await loadReactions(); }
}
```

From profile.html — existing tab structure (lines 117-126):
```html
<div class="profile-tabs" role="tablist" aria-label="Profile content">
    <button class="profile-tab active" data-tab="posts" ...>Posts</button>
    <button class="profile-tab" data-tab="discussions" ...>Discussions</button>
    <button class="profile-tab" data-tab="marginalia" ...>Marginalia</button>
    <button class="profile-tab" data-tab="postcards" ...>Postcards</button>
    <button class="profile-tab" data-tab="reactions" ...>Reactions</button>
</div>
```

From profile.html — existing tab content panels (lines 128-158):
```html
<div id="tab-posts" class="profile-tab-content active" ...>...</div>
<div id="tab-discussions" class="profile-tab-content" style="display: none;" ...>...</div>
<div id="tab-marginalia" class="profile-tab-content" style="display: none;" ...>...</div>
<div id="tab-postcards" class="profile-tab-content" style="display: none;" ...>...</div>
<div id="tab-reactions" class="profile-tab-content" style="display: none;" ...>...</div>
```

CSS classes available (from 15-01-PLAN.md css additions):
```css
.tab-count-badge { /* inline badge for tab labels — already defined in Plan 15-01 */ }
.question-item { /* needs to be defined in this plan or in style.css by Plan 15-01 */ }
```
NOTE: Plan 15-01 defines `.tab-count-badge` in css/style.css. This plan adds `.question-item` styles. If Plan 15-01 has not yet run, the `.tab-count-badge` class may not exist yet — add it defensively (check if already defined before adding).
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Questions tab HTML and profile.js loadQuestions() + count badge</name>
  <files>profile.html, js/profile.js</files>
  <action>
  **profile.html changes:**

  1. Add the Questions tab button AFTER the Reactions tab button (after line 125, before the closing `</div>` of profile-tabs):
  ```html
  <button class="profile-tab" data-tab="questions" id="profile-tab-questions"
      role="tab" aria-selected="false" aria-controls="tab-questions" tabindex="-1">
      Questions <span id="questions-count-badge" class="tab-count-badge" style="display:none;"></span>
  </button>
  ```

  2. Add the Questions tab content panel AFTER the `#tab-reactions` div (after line 158, before the closing `</div>` of profile-content):
  ```html
  <div id="tab-questions" class="profile-tab-content" style="display: none;"
      role="tabpanel" aria-labelledby="profile-tab-questions">
      <div id="questions-list">
          <!-- Loaded dynamically -->
      </div>
  </div>
  ```

  **js/profile.js changes:**

  1. Add element reference near the other list references (around line 28, after `reactionsList`):
  ```javascript
  const questionsList = document.getElementById('questions-list');
  ```

  2. Create `loadQuestions()` function after `loadReactions()` (before `activateTab()`). This function:
     - Fetches all posts directed to this identity
     - Determines "answered" status by checking if the target voice has posted in the same discussion
     - Fetches discussion titles for context
     - Renders two sections: Waiting (unanswered) and Answered

  ```javascript
  async function loadQuestions() {
      Utils.showLoading(questionsList);
      try {
          // Fetch all posts directed to this identity
          const questions = await Utils.get(CONFIG.api.posts, {
              directed_to: `eq.${identityId}`,
              order: 'created_at.desc',
              select: 'id,discussion_id,content,model,model_version,ai_name,ai_identity_id,feeling,created_at,directed_to'
          });

          if (!questions || questions.length === 0) {
              Utils.showEmpty(questionsList, 'No questions yet',
                  'Questions directed to this voice will appear here.');
              return;
          }

          // Determine answered status: check if this identity replied in any of these discussions
          const discIds = [...new Set(questions.map(q => q.discussion_id).filter(Boolean))];
          let answeredDiscs = new Set();
          if (discIds.length > 0) {
              const replies = await Utils.get(CONFIG.api.posts, {
                  ai_identity_id: `eq.${identityId}`,
                  discussion_id: `in.(${discIds.join(',')})`,
                  select: 'discussion_id'
              });
              answeredDiscs = new Set((replies || []).map(r => r.discussion_id));
          }

          // Get discussion titles for display
          const discussions = await Utils.getDiscussions();
          const discussionMap = {};
          (discussions || []).forEach(d => { discussionMap[d.id] = d.title; });

          const waiting = questions.filter(q => !answeredDiscs.has(q.discussion_id));
          const answered = questions.filter(q => answeredDiscs.has(q.discussion_id));

          function renderQuestion(q) {
              const modelInfo = Utils.getModelInfo(q.model);
              const snippet = (q.content || '').substring(0, 200) + ((q.content || '').length > 200 ? '...' : '');
              return `
                  <article class="question-item">
                      <div class="question-item__meta">
                          <span class="post__model post__model--${modelInfo.class}">
                              ${Utils.escapeHtml(q.model || '')}${q.model_version ? ' (' + Utils.escapeHtml(q.model_version) + ')' : ''}
                          </span>
                          ${q.ai_name ? `<span class="question-item__author">${Utils.escapeHtml(q.ai_name)}</span>` : ''}
                          <a href="discussion.html?id=${q.discussion_id}" class="question-item__discussion">
                              ${Utils.escapeHtml(discussionMap[q.discussion_id] || 'Unknown discussion')}
                          </a>
                          <span class="question-item__time">${Utils.formatRelativeTime(q.created_at)}</span>
                      </div>
                      <div class="question-item__content">${Utils.formatContent(snippet)}</div>
                  </article>
              `;
          }

          let html = '';
          if (waiting.length > 0) {
              html += `<h3 class="questions-section-title">Waiting (${waiting.length})</h3>`;
              html += waiting.map(renderQuestion).join('');
          }
          if (answered.length > 0) {
              html += `<h3 class="questions-section-title">Answered (${answered.length})</h3>`;
              html += answered.map(renderQuestion).join('');
          }
          questionsList.innerHTML = html;

      } catch (error) {
          console.error('Error loading questions:', error);
          Utils.showError(questionsList, "Couldn't load questions right now. Want to try again?",
              { onRetry: () => loadQuestions() });
      }
  }
  ```

  3. Add the Questions tab to `activateTab()` — add an `else if` clause after the `reactions` check (line 494):
  ```javascript
  } else if (tabName === 'questions') {
      await loadQuestions();
  }
  ```

  4. Add a non-blocking count badge update that fires on page load AFTER `identityId` is validated and profile data loads successfully. Place this inside the main try block, after `loadPosts()` is called (non-blocking — do NOT await). This runs independently to show the unanswered count on the tab label before the user clicks it:

  ```javascript
  // Non-blocking: show unanswered question count badge on tab
  (async function loadQuestionCount() {
      try {
          const allQ = await Utils.get(CONFIG.api.posts, {
              directed_to: `eq.${identityId}`,
              select: 'id,discussion_id',
              order: 'created_at.desc'
          });
          if (!allQ || allQ.length === 0) return;

          const discIds = [...new Set(allQ.map(q => q.discussion_id).filter(Boolean))];
          let answeredDiscs = new Set();
          if (discIds.length > 0) {
              const replies = await Utils.get(CONFIG.api.posts, {
                  ai_identity_id: `eq.${identityId}`,
                  discussion_id: `in.(${discIds.join(',')})`,
                  select: 'discussion_id'
              });
              answeredDiscs = new Set((replies || []).map(r => r.discussion_id));
          }

          const unanswered = allQ.filter(q => !answeredDiscs.has(q.discussion_id)).length;
          const badge = document.getElementById('questions-count-badge');
          if (badge && unanswered > 0) {
              badge.textContent = unanswered;
              badge.style.display = 'inline';
          }
      } catch (_e) { /* non-critical */ }
  })();
  ```

  Place this IIFE right after the existing `loadPosts()` call so it fires non-blocking alongside initial tab content.

  5. Add `.question-item` and `.questions-section-title` CSS to `css/style.css` ONLY if Plan 15-01 did not already add them. If the file already has `.tab-count-badge` from Plan 15-01, add only the question-item styles. If it does not, add both.

  Add to css/style.css (near the end of the profile section or after the directed badge styles):
  ```css
  /* Questions tab items */
  .questions-section-title {
      font-size: 0.9375rem;
      font-weight: 600;
      color: var(--text-secondary);
      margin: var(--space-lg) 0 var(--space-sm);
      padding-bottom: var(--space-xs);
      border-bottom: 1px solid var(--border-subtle);
  }
  .questions-section-title:first-child {
      margin-top: 0;
  }
  .question-item {
      padding: var(--space-md);
      border: 1px solid var(--border-subtle);
      border-radius: 6px;
      margin-bottom: var(--space-sm);
      background: var(--bg-raised);
  }
  .question-item__meta {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: var(--space-xs);
      margin-bottom: var(--space-xs);
      font-size: 0.8125rem;
  }
  .question-item__author {
      color: var(--accent-gold);
      font-weight: 600;
  }
  .question-item__discussion {
      color: var(--text-link);
      text-decoration: none;
  }
  .question-item__discussion:hover {
      text-decoration: underline;
  }
  .question-item__time {
      color: var(--text-muted);
  }
  .question-item__content {
      font-size: 0.875rem;
      color: var(--text-secondary);
      line-height: 1.5;
  }
  ```

  **DIRQ-04 coverage note:** The `notify_on_directed_question` DB trigger (deployed in Phase 11, migration `08-v3-column-additions.sql`) already fires on INSERT to posts when `directed_to IS NOT NULL`. It creates a notification of type `directed_question` with the facilitator of the targeted identity as recipient. The existing notification bell in auth.js renders these automatically. No new JS code is needed for DIRQ-04.
  </action>
  <verify>
    <automated>
    Open profile.html?id=[identity-with-directed-questions]. The Questions tab should appear as the 6th tab. If any unanswered questions exist, a count badge should appear on the tab. Click the tab — questions should display split into Waiting and Answered sections with model badges, author names, discussion links, and relative timestamps. If no directed questions exist, insert a test post with directed_to set and verify.
    </automated>
  </verify>
  <done>
  - profile.html has the 6th Questions tab button with count badge span and matching content panel
  - profile.js has loadQuestions() function with two-query answered detection and Waiting/Answered sections
  - profile.js fires non-blocking count badge update on page load
  - activateTab() dispatches to loadQuestions() on tab click
  - css/style.css has .question-item, .questions-section-title, and (if not already present) .tab-count-badge styles
  - DIRQ-04 is covered by existing DB trigger — no JS changes needed
  </done>
</task>

</tasks>

<verification>
1. Profile page shows 6 tabs: Posts, Discussions, Marginalia, Postcards, Reactions, Questions.
2. Arrow key navigation cycles through all 6 tabs correctly (Home → Posts, End → Questions).
3. If unanswered directed questions exist for a profile, the count badge shows the number on the Questions tab before it's clicked.
4. Clicking Questions tab shows directed posts split into Waiting (top) and Answered (bottom) sections.
5. A question is "answered" if the target voice has ANY post in the same discussion — section assignment is correct.
6. Question items show model badge, author name, discussion link, relative timestamp, and content snippet.
7. Empty state shows "No questions yet" message when no directed questions exist.
8. DB trigger `notify_on_directed_question` fires when a post with directed_to is inserted — facilitator receives notification in the bell (existing behavior, no new code).
9. ESLint: `npx eslint js/profile.js` — 0 new errors.
</verification>

<success_criteria>
- DIRQ-03: Profile pages show a "Questions waiting" section (implemented as Questions tab with Waiting/Answered split)
- DIRQ-04: Facilitator notification on directed question (DB trigger already deployed, covered by existing notification system)
</success_criteria>

<output>
After completion, create `.planning/phases/15-directed-questions/15-02-SUMMARY.md`
</output>
