---
phase: 04-xss-prevention
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - js/admin.js
  - js/moment.js
  - js/voices.js
  - js/profile.js
autonomous: true
requirements: [SECR-01]

must_haves:
  truths:
    - "admin.js has no local escapeHtml or formatContent function — all calls go through Utils.escapeHtml() and Utils.formatContent()"
    - "moment.js formatDescription uses Utils.escapeHtml() instead of manual regex-based HTML entity escaping"
    - "Every innerHTML assignment across all JS files that interpolates database-sourced content uses Utils.escapeHtml() or Utils.formatContent()"
    - "No JS file outside utils.js defines its own escapeHtml or formatContent function"
  artifacts:
    - path: "js/admin.js"
      provides: "Admin panel with all escaping delegated to Utils.*"
      contains: "Utils.escapeHtml"
    - path: "js/moment.js"
      provides: "Moment page with Utils-based description formatting"
      contains: "Utils.escapeHtml"
    - path: "js/voices.js"
      provides: "Voices page with escaped avatar initial"
      contains: "Utils.escapeHtml"
    - path: "js/profile.js"
      provides: "Profile page with escaped avatar initial"
      contains: "Utils.escapeHtml"
  key_links:
    - from: "js/admin.js"
      to: "js/utils.js"
      via: "Utils.escapeHtml() and Utils.formatContent() calls"
      pattern: "Utils\\.escapeHtml|Utils\\.formatContent"
    - from: "js/moment.js"
      to: "js/utils.js"
      via: "Utils.escapeHtml() in formatDescription"
      pattern: "Utils\\.escapeHtml"
---

<objective>
Replace all local escapeHtml/formatContent functions with Utils.* calls and fix remaining unescaped innerHTML interpolations across the codebase.

Purpose: SECR-01 requires that every innerHTML assignment rendering user-generated content goes through Utils.escapeHtml() or Utils.formatContent(). admin.js has local copies of both functions that must be replaced. moment.js has manual regex-based escaping. Two files have unescaped charAt(0) in innerHTML.

Output: 4 JS files updated with consistent Utils.* escaping; zero local escapeHtml/formatContent functions outside utils.js.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-xss-prevention/04-RESEARCH.md

@js/admin.js
@js/moment.js
@js/voices.js
@js/profile.js
</context>

<interfaces>
<!-- Key interfaces the executor needs from utils.js -->

From js/utils.js (the canonical helpers — all replacements must use these):
```javascript
// Returns HTML-escaped string (safe for innerHTML interpolation)
escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
},

// Escapes first, then adds <p>, <br>, <strong>, <a> tags
// Returns formatted HTML string safe for innerHTML
formatContent(text) {
    let formatted = this.escapeHtml(text);
    formatted = formatted.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
    formatted = formatted.replace(
        /(https?:\/\/[^\s<]+)/g,
        '<a href="$1" target="_blank" rel="noopener">$1</a>'
    );
    const paragraphs = formatted.split(/\n\n+/);
    return paragraphs
        .map(p => p.trim())
        .filter(p => p)
        .map(p => `<p>${p.replace(/\n/g, '<br>')}</p>`)
        .join('');
},
```

NOTE: admin.js local `formatContent` splits on `\n` (single newlines) while Utils.formatContent splits on `\n\n+` (double newlines) and adds `<br>` for single newlines. The admin local version is simpler — after migration, admin content will render slightly differently (paragraphs grouped by double-newlines with `<br>` for singles, plus bold and URL support). This is acceptable — admin.js renders moderation content where the richer formatting is an improvement.
</interfaces>

<tasks>

<task type="auto">
  <name>Task 1: Replace admin.js local escapeHtml/formatContent with Utils.* calls</name>
  <files>js/admin.js</files>
  <action>
**Step 1 — Delete local helper functions:**

Remove the local `escapeHtml` function (lines 386-391) and the local `formatContent` function (lines 404-411) from admin.js. Also remove the local `formatDate` function (lines 393-402) — it is used nowhere in admin.js since all dates use a separate rendering pattern.

Actually, first verify: search admin.js for calls to `formatDate(` to confirm it is unused. If it IS used, leave it in place.

**Step 2 — Replace all bare `escapeHtml(` calls with `Utils.escapeHtml(`:**

admin.js uses `escapeHtml(...)` approximately 40+ times throughout its render functions. Replace every occurrence of `escapeHtml(` with `Utils.escapeHtml(`. The function signature is identical — `Utils.escapeHtml(text)` takes a string and returns an escaped string.

IMPORTANT: The Utils version does NOT have the `if (!text) return '';` guard that the local version has. However, this is safe because:
- The div.textContent = null/undefined results in "null"/"undefined" as innerHTML, which is the same as what `String(text)` would produce
- Every call site already guards with conditional rendering (e.g., `post.feeling ? ... escapeHtml(post.feeling) : ''`)

**Step 3 — Replace all bare `formatContent(` calls with `Utils.formatContent(`:**

Replace every occurrence of `formatContent(` with `Utils.formatContent(`. There are approximately 5-6 calls (renderPosts, renderMarginalia, renderPostcards, renderContacts, renderTextSubmissions).

IMPORTANT: The Utils version also lacks the `if (!text) return '';` guard. Review each call site — if the input could be null/undefined AND is not already guarded by a conditional, add an inline guard: `Utils.formatContent(text || '')`.

**Step 4 — Verify no remaining bare calls:**

After replacement, search the file for any remaining `escapeHtml(` or `formatContent(` that are NOT prefixed with `Utils.`. There should be zero.
  </action>
  <verify>
    <automated>node -e "const fs=require('fs');const a=fs.readFileSync('js/admin.js','utf8');const localFn=/function\s+escapeHtml|function\s+formatContent/.test(a);if(localFn){console.error('FAIL: local helper functions still exist');process.exit(1)};const bare=/[^.]escapeHtml\(|[^.]formatContent\(/.test(a);const hasUtils=/Utils\.escapeHtml\(/.test(a)&&/Utils\.formatContent\(/.test(a);if(!hasUtils){console.error('FAIL: Utils.escapeHtml or Utils.formatContent not found');process.exit(1)};console.log('PASS: admin.js uses Utils.* helpers, no local definitions')"</automated>
  </verify>
  <done>
    - admin.js contains zero local escapeHtml/formatContent function definitions
    - All ~40 escapeHtml calls now read Utils.escapeHtml(...)
    - All ~6 formatContent calls now read Utils.formatContent(...)
    - admin.html already loads utils.js (confirmed in Phase 3 — 03-02)
  </done>
</task>

<task type="auto">
  <name>Task 2: Fix remaining innerHTML escaping gaps in moment.js, voices.js, profile.js</name>
  <files>js/moment.js, js/voices.js, js/profile.js</files>
  <action>
**Fix 1 — moment.js `formatDescription()` (line 108):**

The local `formatDescription()` function manually escapes using regex: `.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')`. This is functionally correct but is a hand-rolled escaping pattern that bypasses Utils.

Replace the three manual regex lines (lines 112-114) with a call to `Utils.escapeHtml()`:

BEFORE (lines 110-114):
```javascript
return text
    // Escape HTML first
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
```

AFTER:
```javascript
return Utils.escapeHtml(text)
```

The rest of the function (bold, italic, hr, header, list, paragraph transforms) stays unchanged — those transforms operate on already-escaped text, producing safe HTML. The key change is that escaping now goes through the canonical Utils function.

IMPORTANT: `Utils.escapeHtml()` uses the `div.textContent/div.innerHTML` technique which also escapes `"` and `'` (as `&quot;` and `&#039;`). The manual regex only escaped `&`, `<`, `>`. The additional escaping is strictly safer and should not affect rendering (quotes inside text content are not special in HTML body context).

**Fix 2 — voices.js line 60 — unescaped `charAt(0)` in innerHTML:**

BEFORE (line 60):
```javascript
${identity.name.charAt(0).toUpperCase()}
```

AFTER:
```javascript
${Utils.escapeHtml(identity.name.charAt(0).toUpperCase())}
```

Per research Open Question 1: a single character cannot form a complete XSS payload, but applying escapeHtml costs nothing and keeps the audit rule simple ("all user data in innerHTML goes through Utils").

**Fix 3 — profile.js line 77 — unescaped `charAt(0)` in innerHTML:**

BEFORE (line 77):
```javascript
profileAvatar.innerHTML = `<div class="profile-avatar__initial profile-avatar__initial--${modelClass}">${identity.name.charAt(0).toUpperCase()}</div>`;
```

AFTER:
```javascript
profileAvatar.innerHTML = `<div class="profile-avatar__initial profile-avatar__initial--${modelClass}">${Utils.escapeHtml(identity.name.charAt(0).toUpperCase())}</div>`;
```

Same rationale as Fix 2.

**Verification scan — confirm no remaining gaps:**

After making these fixes, run a final grep across all JS files for innerHTML assignments that interpolate database content without Utils.*. The following files should show ZERO unescaped user data in innerHTML:
- moment.js, moments.js, voices.js, discussions.js, reading-room.js, home.js, profile.js, search.js, submit.js, chat.js, discussion.js, text.js, postcards.js, dashboard.js

The only file with remaining local formatting is moment.js `formatDescription()` which now starts with `Utils.escapeHtml()`.
  </action>
  <verify>
    <automated>node -e "const fs=require('fs');const m=fs.readFileSync('js/moment.js','utf8');if(m.includes('.replace(/&/g')){console.error('FAIL: moment.js still has manual regex escaping');process.exit(1)};if(!m.includes('Utils.escapeHtml')){console.error('FAIL: moment.js missing Utils.escapeHtml');process.exit(1)};const v=fs.readFileSync('js/voices.js','utf8');const p=fs.readFileSync('js/profile.js','utf8');const vCharAt=/charAt\(0\)[^)]*\)(?!\s*\))/.test(v);if(v.includes('charAt(0)')&&!v.includes('Utils.escapeHtml(identity.name.charAt')){console.error('FAIL: voices.js charAt(0) not escaped');process.exit(1)};if(p.includes('charAt(0)')&&!p.includes('Utils.escapeHtml(identity.name.charAt')){console.error('FAIL: profile.js charAt(0) not escaped');process.exit(1)};console.log('PASS: moment.js, voices.js, profile.js all use Utils.escapeHtml')"</automated>
  </verify>
  <done>
    - moment.js formatDescription uses Utils.escapeHtml() instead of manual regex
    - voices.js avatar initial wrapped in Utils.escapeHtml()
    - profile.js avatar initial wrapped in Utils.escapeHtml()
    - grep for `function escapeHtml` across all JS files returns only utils.js
  </done>
</task>

</tasks>

<verification>
1. `grep -rn "function escapeHtml\|function formatContent" js/` returns ONLY utils.js hits (the canonical implementations)
2. `grep -c "Utils.escapeHtml" js/admin.js` returns 30+ (was 0, now all calls use Utils.*)
3. `grep -c "Utils.formatContent" js/admin.js` returns 5+ (was 0, now all calls use Utils.*)
4. `grep -c "Utils.escapeHtml" js/moment.js` returns at least 3 (external_links + formatDescription)
5. `grep "charAt(0)" js/voices.js js/profile.js` — all instances wrapped in Utils.escapeHtml()
6. `npx eslint@9 js/admin.js js/moment.js js/voices.js js/profile.js` — no new errors introduced
</verification>

<success_criteria>
- SECR-01: Every innerHTML assignment rendering user-generated content goes through Utils.escapeHtml() or Utils.formatContent() — no raw interpolation, no local helper copies
- Zero local escapeHtml/formatContent function definitions outside utils.js
- moment.js uses Utils.escapeHtml instead of manual regex escaping
- All charAt(0) avatar initials in innerHTML are escaped
</success_criteria>

<output>
After completion, create `.planning/phases/04-xss-prevention/04-02-SUMMARY.md`
</output>
