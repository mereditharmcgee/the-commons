# Plan 20-02: Form Validation for Contact & Claim Pages

---
wave: 2
depends_on: [20-01]
files_modified:
  - contact.html
  - claim.html
autonomous: true
requirements: [FORM-01, FORM-02]
---

## Goal

Add client-side form validation to contact.html and claim.html using the existing Utils.validate() pattern, with inline error messages below invalid fields. Both pages get email format validation and proper error feedback before any submission occurs.

## Context

### Utils.validate() API (js/utils.js line 380)
The validate function accepts an array of field descriptors:
```js
Utils.validate([
  { id: 'field-id', label: 'Field Name', rules: { required: true, pattern: /regex/, patternMessage: 'Custom error' } }
])
```
- Returns `true` if all pass, `false` if any fail
- Automatically adds `.form-input--error` / `.form-textarea--error` class to failing fields
- Creates `.form-error` divs below each failing field
- Clears previous errors on each call

### FORM-01: contact.html validation needs
- Email field is optional, but if provided, must be valid format
- Message field is required (already checked manually, but should use Utils.validate for consistency)
- Email length check (reasonable max, e.g. 254 chars per RFC)
- Validate on submit only (per user decision in 20-CONTEXT.md)
- Submit button should disable during submission (already does this)

### FORM-02: claim.html validation needs
- Account email is required AND must be valid email format
- AI names field is required
- Facilitator email is optional but if provided must be valid format
- Validate on submit only

### Email regex pattern
Standard email pattern: `/^[^\s@]+@[^\s@]+\.[^\s@]+$/` — matches typical emails without being overly strict.

### Current code patterns
Both pages use inline `<script>` blocks with form submission handlers. The validation needs to:
1. Call Utils.validate() before proceeding
2. Return early if validation fails
3. Keep existing honeypot check and submission logic

## Tasks

<task id="20-02-01">
<title>Add Utils.validate() to contact.html form submission</title>
<steps>
1. In contact.html's `<script>` block, inside the form submit handler (after `e.preventDefault()` and before the existing manual message check), add a Utils.validate() call:
```js
const isValid = Utils.validate([
    {
        id: 'email',
        label: 'Email',
        rules: {
            pattern: /^$|^[^\s@]+@[^\s@]+\.[^\s@]+$/,
            patternMessage: 'Please enter a valid email address.',
            maxLength: 254
        }
    },
    {
        id: 'message',
        label: 'Message',
        rules: { required: true }
    }
]);

if (!isValid) {
    resetButton();
    return;
}
```
2. Remove the existing manual message check (`if (!data.message) { ... }`) since Utils.validate() now handles it
3. Move the button disable (`submitBtn.disabled = true; submitBtn.textContent = 'Sending...';`) to AFTER the validation check (so the button stays enabled when validation fails)
4. Add `<span id="email-error" class="form-error" role="alert"></span>` after the email input (or after the form-help paragraph) so error messages have a natural placement — actually Utils.validate() creates its own .form-error div dynamically via parentElement.appendChild, so no HTML change needed
5. Add `aria-describedby` attributes: email input gets `aria-describedby="email-error"`, message textarea gets `aria-describedby="message-error"` — but since Utils.validate creates dynamic errors, this is optional. Skip to keep changes minimal.
</steps>
</task>

<task id="20-02-02">
<title>Add Utils.validate() to claim.html form submission</title>
<steps>
1. In claim.html's `<script>` block, inside the form submit handler, replace the existing manual validation (`if (!accountEmail || !aiNames)`) with Utils.validate():
```js
const isValid = Utils.validate([
    {
        id: 'account-email',
        label: 'Account email',
        rules: {
            required: true,
            pattern: /^[^\s@]+@[^\s@]+\.[^\s@]+$/,
            patternMessage: 'Please enter a valid email address.',
            maxLength: 254
        }
    },
    {
        id: 'ai-names',
        label: 'AI name(s)',
        rules: { required: true }
    },
    {
        id: 'facilitator-email',
        label: 'Facilitator email',
        rules: {
            pattern: /^$|^[^\s@]+@[^\s@]+\.[^\s@]+$/,
            patternMessage: 'Please enter a valid email address.',
            maxLength: 254
        }
    }
]);

if (!isValid) {
    resetButton();
    return;
}
```
2. Remove the existing manual validation block (`if (!accountEmail || !aiNames) { showMessage(...); resetButton(); return; }`)
3. Move the button disable (`submitBtn.disabled = true; submitBtn.textContent = 'Submitting...';`) to AFTER the validation check
4. Keep the honeypot check and submission logic unchanged
</steps>
</task>

## Verification

- [ ] contact.html: submitting with a filled-but-invalid email (e.g., "not-an-email") shows inline error below the email field
- [ ] contact.html: submitting with empty message shows inline "Message is required" error
- [ ] contact.html: submitting with valid data (or empty optional email) proceeds normally
- [ ] contact.html: the email field gets `.form-input--error` class on invalid input, cleared on next submit attempt
- [ ] claim.html: submitting with empty account email shows inline "Account email is required" error
- [ ] claim.html: submitting with invalid account email format shows "Please enter a valid email address" error
- [ ] claim.html: submitting with empty AI names shows inline "AI name(s) is required" error
- [ ] claim.html: optional facilitator email validates format if provided
- [ ] claim.html: submitting with valid data proceeds normally
- [ ] Both pages: submit button stays enabled when validation fails (not stuck in disabled state)

## must_haves
- contact.html validates email format and message presence using Utils.validate()
- claim.html validates email format and required fields using Utils.validate()
- Inline error messages appear below invalid fields
- Submit buttons remain enabled after validation failure
