---
phase: 18-dashboard-bug-fixes
plan: 03
type: execute
wave: 2
depends_on:
  - 18-02
files_modified:
  - js/dashboard.js
autonomous: true
requirements:
  - DASH-06
  - DASH-07
  - DASH-11

must_haves:
  truths:
    - "Notification filter tabs and mark-all-read survive AbortErrors via Utils.withRetry()"
    - "Event listeners for .edit-identity-btn, .unsubscribe-btn, and .revoke-token-btn are scoped to their container elements"
    - "Token loading fetches identities and tokens in parallel via Promise.all, not sequentially with a duplicate call"
  artifacts:
    - path: "js/dashboard.js"
      provides: "withRetry on notification actions, container-scoped selectors, parallel token loading"
  key_links:
    - from: "js/dashboard.js"
      to: "loadNotifications"
      via: "Utils.withRetry wrapper on filter tab and mark-all-read"
      pattern: "withRetry.*loadNotifications"
    - from: "js/dashboard.js"
      to: "identitiesList"
      via: "scoped querySelector for .edit-identity-btn"
      pattern: "identitiesList\\.querySelectorAll"
    - from: "js/dashboard.js"
      to: "Promise.all"
      via: "parallel loading of tokens and identities"
      pattern: "Promise\\.all"
---

<objective>
Fix three JS quality/reliability bugs: missing retry wrappers on notification actions, document-scoped event listener selectors, and duplicate sequential API calls in token loading.

Purpose: Without withRetry, notification tabs break on Supabase AbortError. Document-scoped selectors can attach handlers to wrong elements. Sequential duplicate calls waste bandwidth and time.
Output: Resilient notification actions, correctly scoped event handlers, efficient parallel data loading.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@js/dashboard.js
@.planning/phases/18-dashboard-bug-fixes/18-02-SUMMARY.md

<interfaces>
<!-- From js/utils.js -->
Utils.withRetry(fn)  — Retries on AbortError from Supabase client auth state changes
Utils.escapeHtml(str) — HTML entity encoding

<!-- From js/auth.js -->
Auth.getMyIdentities() — Returns user's AI identities array
Auth.getNotifications(limit, unreadOnly, type, offset) — Paginated notifications
Auth.markAllAsRead() — Marks all notifications as read
Auth.updateNotificationBadge() — Updates nav bell badge

<!-- From js/agent-admin.js -->
AgentAdmin.getAllMyTokens() — Fetches tokens. NOTE: This internally calls Auth.getMyIdentities()
                               so calling both sequentially means identities are fetched twice.
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wrap notification actions in withRetry and scope event selectors to containers</name>
  <files>js/dashboard.js</files>
  <action>
**DASH-06 — Add withRetry to notification filter tabs and mark-all-read:**

In the notification filter tab click handler (around line 405-416), the tab click calls `loadNotifications(false)` directly. Wrap it:

Change:
```javascript
tab.addEventListener('click', () => {
    // ... filter tab UI updates ...
    activeFilterType = tab.dataset.type || null;
    loadNotifications(false);
});
```
To:
```javascript
tab.addEventListener('click', () => {
    // ... filter tab UI updates ...
    activeFilterType = tab.dataset.type || null;
    Utils.withRetry(() => loadNotifications(false)).catch(e => console.error('Notification filter failed:', e));
});
```

In the mark-all-read handler (around line 442-446), wrap the calls:

Change:
```javascript
markAllReadBtn.addEventListener('click', async () => {
    await Auth.markAllAsRead();
    await loadNotifications(false);
    Auth.updateNotificationBadge();
});
```
To:
```javascript
markAllReadBtn.addEventListener('click', async () => {
    try {
        await Utils.withRetry(() => Auth.markAllAsRead());
        await Utils.withRetry(() => loadNotifications(false));
        Auth.updateNotificationBadge();
    } catch (e) {
        console.error('Mark all read failed:', e);
    }
});
```

**DASH-07 — Scope querySelectorAll to container elements:**

Three places use `document.querySelectorAll()` when they should scope to their container:

1. In `loadIdentities()` (around line 190), change:
```javascript
document.querySelectorAll('.edit-identity-btn').forEach(btn => {
```
To:
```javascript
identitiesList.querySelectorAll('.edit-identity-btn').forEach(btn => {
```

2. In `loadIdentities()` (around line 195), change:
```javascript
document.querySelectorAll('.unpin-identity-btn').forEach(function(btn) {
```
To:
```javascript
identitiesList.querySelectorAll('.unpin-identity-btn').forEach(function(btn) {
```

3. In `loadSubscriptions()` (around line 507), change:
```javascript
document.querySelectorAll('.unsubscribe-btn').forEach(btn => {
```
To:
```javascript
subscriptionsList.querySelectorAll('.unsubscribe-btn').forEach(btn => {
```

4. In `loadTokens()` (around line 648), change:
```javascript
document.querySelectorAll('.revoke-token-btn').forEach(btn => {
```
To:
```javascript
tokensList.querySelectorAll('.revoke-token-btn').forEach(btn => {
```

All four container variables (`identitiesList`, `subscriptionsList`, `tokensList`) are already declared at the top of the IIFE. These scoped selectors ensure handlers only bind to buttons within the correct section, not any matching class anywhere in the document.
  </action>
  <verify>
    <automated>cd C:/Users/mmcge/the-commons && grep -c "identitiesList.querySelectorAll" js/dashboard.js | grep -q "2" && grep -q "subscriptionsList.querySelectorAll" js/dashboard.js && grep -q "tokensList.querySelectorAll" js/dashboard.js && grep "withRetry.*loadNotifications" js/dashboard.js | head -1 && grep "withRetry.*markAllAsRead" js/dashboard.js | head -1 && echo "DASH-06 and DASH-07 OK"</automated>
  </verify>
  <done>Notification filter tabs and mark-all-read are wrapped in Utils.withRetry(). All querySelectorAll calls for .edit-identity-btn, .unpin-identity-btn, .unsubscribe-btn, and .revoke-token-btn are scoped to their container elements.</done>
</task>

<task type="auto">
  <name>Task 2: Use Promise.all for parallel token and identity loading</name>
  <files>js/dashboard.js</files>
  <action>
**DASH-11 — Parallel token loading with Promise.all:**

The current `loadTokens()` function (around line 559-672) calls `AgentAdmin.getAllMyTokens()` and then `Auth.getMyIdentities()` sequentially. But `AgentAdmin.getAllMyTokens()` internally also calls `Auth.getMyIdentities()`, meaning identities are fetched twice.

Restructure `loadTokens()` to use `Promise.all` for parallel fetching:

```javascript
async function loadTokens() {
    if (!tokensList) return;

    tokensList.innerHTML = '<p class="text-muted">Loading...</p>';

    try {
        const [tokens, identities] = await Promise.all([
            AgentAdmin.getAllMyTokens(),
            Auth.getMyIdentities()
        ]);

        if (!identities || identities.length === 0) {
            tokensList.innerHTML = `
                <div class="dashboard-empty">
                    <p>Create an AI identity first to generate agent tokens.</p>
                </div>
            `;
            return;
        }

        // ... rest of the function remains exactly the same ...
        // (Build tokens list HTML, add event handlers, etc.)
```

The key change is replacing the sequential:
```javascript
const tokens = await AgentAdmin.getAllMyTokens();
const identities = await Auth.getMyIdentities();
```
With the parallel:
```javascript
const [tokens, identities] = await Promise.all([
    AgentAdmin.getAllMyTokens(),
    Auth.getMyIdentities()
]);
```

This fires both requests concurrently. Even though `getAllMyTokens` internally fetches identities too, the separate `Auth.getMyIdentities()` call here is needed for the modal dropdown and identity-check logic later in the function. The parallel fetch still saves one sequential round-trip.

Do NOT modify anything else in the function — the HTML rendering, event handlers, and modal logic remain unchanged.
  </action>
  <verify>
    <automated>cd C:/Users/mmcge/the-commons && grep -q "Promise.all" js/dashboard.js && grep -A2 "Promise.all" js/dashboard.js | grep -q "getAllMyTokens" && grep -A2 "Promise.all" js/dashboard.js | grep -q "getMyIdentities" && echo "DASH-11 OK"</automated>
  </verify>
  <done>loadTokens() uses Promise.all to fetch tokens and identities in parallel instead of sequentially. Both API calls fire concurrently, saving one round-trip.</done>
</task>

</tasks>

<verification>
1. Switch notification filter tabs rapidly — no errors from AbortError
2. Mark all read — notifications reload without errors
3. Inspect rendered HTML: .edit-identity-btn handlers only exist inside #identities-list, .revoke-token-btn only inside #tokens-list
4. Network tab: loadTokens triggers both requests simultaneously, not sequentially
</verification>

<success_criteria>
- Notification filter tab clicks and mark-all-read use Utils.withRetry()
- All four querySelectorAll calls for action buttons are scoped to container elements
- loadTokens() uses Promise.all for parallel fetching of tokens and identities
- No document.querySelectorAll('.edit-identity-btn'), document.querySelectorAll('.unsubscribe-btn'), or document.querySelectorAll('.revoke-token-btn') remain
</success_criteria>

<output>
After completion, create `.planning/phases/18-dashboard-bug-fixes/18-03-SUMMARY.md`
</output>
