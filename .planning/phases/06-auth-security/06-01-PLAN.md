---
phase: 06-auth-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - .planning/phases/06-auth-security/rls-audit.md
autonomous: false
requirements:
  - SECR-07

must_haves:
  truths:
    - "Every Supabase table has documented expected access patterns (who can SELECT, INSERT, UPDATE, DELETE)"
    - "Every gap between expected and actual RLS policy is identified with risk assessment"
    - "Corrective SQL is produced for any unacceptable gaps and ready to apply in the Supabase SQL Editor"
    - "Intentional design choices (e.g., public INSERT with WITH CHECK true for anonymous posting) are documented as accepted risks"
  artifacts:
    - path: ".planning/phases/06-auth-security/rls-audit.md"
      provides: "Complete RLS audit document with per-table policy analysis, gap inventory, and corrective SQL"
      contains: "Expected Access|Actual Policy|Gap Analysis"
  key_links:
    - from: "sql/schema/*.sql"
      to: ".planning/phases/06-auth-security/rls-audit.md"
      via: "Policy reconstruction from SQL source files"
      pattern: "CREATE POLICY|DROP POLICY"
    - from: "sql/admin/*.sql"
      to: ".planning/phases/06-auth-security/rls-audit.md"
      via: "Admin policy overlay from admin SQL files"
      pattern: "is_admin|admin-rls"
---

<objective>
Audit all Supabase RLS policies by reconstructing the current policy state from SQL source files, documenting expected vs actual access patterns for every table, identifying gaps, and producing corrective SQL for any unacceptable gaps.

Purpose: SECR-07 requires all tables to have documented expected access patterns with any policy gap fixed. The blocker in STATE.md ("Supabase Dashboard access required") is resolved by reading the accumulated SQL source files directly.

Output: `rls-audit.md` containing per-table analysis and corrective SQL ready for the Supabase SQL Editor. No code changes to the repository — all fixes are SQL applied in the Supabase Dashboard.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/06-auth-security/06-RESEARCH.md

## Source SQL files (reconstruct all policies from these)
@sql/schema/01-schema.sql
@sql/schema/02-identity-system.sql
@sql/schema/03-agent-system.sql
@sql/schema/04-chat-schema.sql
@sql/schema/05-moments-schema.sql
@sql/schema/06-reading-room-schema.sql
@sql/schema/07-postcards-schema.sql
@sql/schema/08-contact-schema.sql
@sql/schema/09-text-submissions-setup.sql
@sql/schema/10-user-post-management.sql
@sql/admin/admin-setup.sql
@sql/admin/admin-rls-setup.sql

<interfaces>
<!-- No code interfaces needed — this is a documentation + SQL task -->
<!-- The research file (06-RESEARCH.md) contains the full per-table policy reconstruction already -->
<!-- Task 1 should use the research as the primary input, verify against SQL files, and format as the audit document -->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create RLS audit document from SQL source analysis</name>
  <files>.planning/phases/06-auth-security/rls-audit.md</files>
  <action>
Create `.planning/phases/06-auth-security/rls-audit.md` with the following structure:

**1. Table Inventory**
List all tables found in SQL source files. The research identifies 17 tables: discussions, posts, marginalia, facilitators, ai_identities, subscriptions, notifications, agent_tokens, agent_activity, texts, text_submissions, contact, moments, chat_rooms, chat_messages, postcards, postcard_prompts. Note: the requirement says "13 tables" — document the actual count from source files and note the discrepancy.

Include a verification SQL query block at the top that the user should run in the Supabase SQL Editor to confirm the live table list:
```sql
SELECT tablename FROM pg_tables WHERE schemaname = 'public' ORDER BY tablename;
```

And the policy listing query:
```sql
SELECT tablename, policyname, cmd, permissive, qual AS using_expression, with_check AS check_expression
FROM pg_policies WHERE schemaname = 'public'
ORDER BY tablename, policyname;
```

**2. Per-Table Analysis**
For each table, create a section with:
- **Source file**: Which SQL file defines the table
- **Expected access pattern**: Who should be able to SELECT, INSERT, UPDATE, DELETE and under what conditions
- **Actual policies**: Reconstructed from all SQL files (schema + admin + patches), noting any DROP POLICY + re-create that supersedes earlier policies
- **Gap analysis**: Any mismatch between expected and actual
- **Risk level**: LOW (intentional design choice), MEDIUM (suboptimal but not exploitable), HIGH (unintended data exposure)
- **Status**: ACCEPTED (intentional), NEEDS FIX (corrective SQL below), or CLEAN (no gap)

Use the comprehensive per-table analysis from `06-RESEARCH.md` as the primary source. Verify each table's analysis by reading the actual SQL source files. The research already identifies these key gaps:

- `discussions`: Public INSERT with `WITH CHECK (true)` — intentional for anonymous posting (ACCEPTED)
- `posts`: Public INSERT allows `facilitator_id` spoof — accepted platform design (ACCEPTED)
- `marginalia`: Same `facilitator_id` spoof risk as posts (ACCEPTED)
- `ai_identities`: No user DELETE — intentional soft-delete pattern (ACCEPTED)
- `agent_tokens`: No DELETE — intentional audit trail preservation (ACCEPTED)
- `texts`: No UPDATE for admins — low risk, accepted limitation (ACCEPTED)
- `text_submissions`: Multiple SELECT policies — correct PostgreSQL OR behavior (CLEAN)
- `contact`: No DELETE — permanent retention, low operational risk (ACCEPTED)
- `moments`: No INSERT/UPDATE/DELETE via frontend — admin-created via Dashboard (ACCEPTED)
- `postcards`: Verify policies from `07-postcards-schema.sql` — not fully covered in research
- `postcard_prompts`: Service role only for mutations (CLEAN)
- `chat_rooms`: Admin FOR ALL + public read active (CLEAN)
- `chat_messages`: Public INSERT with constraints (CLEAN)

**3. Corrective SQL**
If any gap is rated HIGH or MEDIUM-NEEDS-FIX, produce corrective SQL statements. Based on the research, no HIGH gaps exist — all identified gaps are intentional design choices. If this holds after verification, state: "No corrective SQL required — all gaps are intentional design choices, documented above."

**4. Summary**
- Total tables audited: N
- Clean: N tables
- Accepted risks: N tables (with brief list)
- Fixes applied: N (expected: 0)

Also read the patches directory files (`sql/patches/*.sql`) to check for any policy modifications not captured in the research. Specifically check:
- `sql/patches/add-admin-user-policies.sql`
- `sql/patches/postcard-prompts-admin.sql`

These may contain additional policy definitions that override or supplement the schema files.

**Important:** The `postcards` table (from `07-postcards-schema.sql`) is not fully analyzed in the research. Read this file and add the complete policy analysis for postcards.
  </action>
  <verify>
    <automated>grep -c "## Table" .planning/phases/06-auth-security/rls-audit.md</automated>
    Verify the audit document exists and contains per-table sections. Count should be >= 13 (one section per table).
    Also verify: `grep -c "Status:" .planning/phases/06-auth-security/rls-audit.md` returns >= 13.
  </verify>
  <done>
    - rls-audit.md exists with per-table analysis for all tables found in SQL source files
    - Each table has: expected access, actual policies, gap analysis, risk level, status
    - Corrective SQL section is present (even if empty — stating no fixes needed)
    - Summary section present with counts
    - Verification SQL queries included at top for user to run in Supabase SQL Editor
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete RLS audit document analyzing all Supabase tables, their policies, and any access gaps. The audit reconstructs policies from SQL source files and documents every intentional design choice vs actual security gap.</what-built>
  <how-to-verify>
    1. Open `.planning/phases/06-auth-security/rls-audit.md` and review the per-table analysis
    2. Run the verification SQL queries in the Supabase SQL Editor:
       - `SELECT tablename FROM pg_tables WHERE schemaname = 'public' ORDER BY tablename;` — confirm table count matches audit
       - `SELECT tablename, policyname, cmd, permissive, qual, with_check FROM pg_policies WHERE schemaname = 'public' ORDER BY tablename, policyname;` — spot-check 2-3 tables against audit
    3. Review "Accepted Risk" items — confirm they match your understanding of the platform's design
    4. If corrective SQL exists, review and apply it in the Supabase SQL Editor
    5. If no corrective SQL (expected), confirm you agree all gaps are intentional
  </how-to-verify>
  <resume-signal>Type "approved" if the audit is accurate and any corrective SQL has been applied (or confirmed unnecessary). Describe any issues found.</resume-signal>
</task>

</tasks>

<verification>
- [ ] rls-audit.md contains analysis for all tables in the SQL source files
- [ ] Every table has documented expected access patterns
- [ ] Every gap between expected and actual policy is identified
- [ ] Risk levels assigned: LOW, MEDIUM, or HIGH
- [ ] Corrective SQL provided for any MEDIUM-NEEDS-FIX or HIGH gaps
- [ ] User has verified the audit against live Supabase policies
</verification>

<success_criteria>
All Supabase tables have been audited with documented expected access patterns. Any gap between expected and actual policy is identified, risk-assessed, and either fixed (SQL applied in Supabase SQL Editor) or documented as an intentional design choice.
</success_criteria>

<output>
After completion, create `.planning/phases/06-auth-security/06-01-SUMMARY.md`
</output>
