---
phase: 06-auth-security
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - js/dashboard.js
  - reset-password.html
  - login.html
autonomous: true
requirements:
  - SECR-08
  - SECR-09
  - SECR-10

must_haves:
  truths:
    - "A user with an expired session token who visits dashboard.html is redirected to login.html with a 'session expired' message"
    - "A user clicking a password reset link that has already been used or expired sees a clear 'link expired' message with a way to request a new one"
    - "A user clicking a magic link a second time sees a clear message explaining the link was already used and is directed to sign in normally"
    - "login.html reads the 'reason' query parameter and displays the appropriate contextual message"
  artifacts:
    - path: "js/dashboard.js"
      provides: "Expired session redirect and magic link error detection"
      contains: "session_expired|magic_link_expired|otp_expired|error_code"
    - path: "reset-password.html"
      provides: "Expired/reused reset link detection with clear messaging"
      contains: "getSession|link.*expired|request a new"
    - path: "login.html"
      provides: "Contextual message display based on redirect reason"
      contains: "reason.*session_expired|reason.*magic_link"
  key_links:
    - from: "js/dashboard.js"
      to: "login.html"
      via: "window.location.href redirect with reason param"
      pattern: "login\\.html\\?reason="
    - from: "login.html"
      to: "login.html"
      via: "URLSearchParams reading reason param"
      pattern: "URLSearchParams.*reason"
    - from: "reset-password.html"
      to: "login.html"
      via: "Link to login for requesting new reset"
      pattern: "login\\.html"
---

<objective>
Handle three auth edge cases: (1) expired session tokens on auth-gated pages redirect to login with a clear message, (2) expired/reused password reset links show a clear error with recovery path, (3) reused magic links show a clear message instead of silently failing.

Purpose: SECR-08, SECR-09, SECR-10 require that auth failure states never leave users confused or stuck. Currently, expired sessions show a generic "not logged in" block, expired reset links let the form render and fail on submit, and reused magic links silently drop users into the "not logged in" dashboard state.

Output: Modified `js/dashboard.js`, `reset-password.html`, and `login.html` with edge case handling. No new dependencies — all changes use existing Supabase JS v2 auth APIs.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/06-auth-security/06-RESEARCH.md

@js/auth.js
@js/dashboard.js
@reset-password.html
@login.html

<interfaces>
<!-- From js/auth.js — key methods used by edge case handlers -->
Auth.init()           — async, sets Auth.user and Auth.facilitator, sets up onAuthStateChange listener
Auth.isLoggedIn()     — returns !!this.user (boolean)
Auth.getClient()      — returns Supabase client (window._supabaseClient)
Auth.sendPasswordReset(email) — sends reset email via Supabase auth
Auth.signOut()        — signs out, nulls user/facilitator

<!-- From Supabase JS v2 — auth methods used in edge case detection -->
Auth.getClient().auth.getSession() — returns { data: { session }, error }; session is null if no valid session
<!-- URL hash error params from Supabase on failed magic link: #error_code=otp_expired&error_description=... -->

<!-- admin.js has its own auth flow (checkAuth + showLogin) that already handles non-authenticated state -->
<!-- by showing an in-page login form. It does NOT use Auth.init(). No changes needed for admin.js. -->
</interfaces>
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add magic link error detection and expired session redirect to dashboard.js</name>
  <files>js/dashboard.js</files>
  <action>
Modify `js/dashboard.js` to handle two edge cases:

**A) Magic link reuse detection (SECR-10) — BEFORE Auth.init()**

Before the `await Auth.init()` call (currently line 110), add a check for Supabase error parameters in the URL hash. When a magic link is reused, Supabase redirects to the landing page with error info in the URL fragment.

```javascript
// Check for magic link error in URL hash (before Auth.init processes it)
const hashParams = new URLSearchParams(window.location.hash.substring(1));
const errorCode = hashParams.get('error_code');
const errorDescription = hashParams.get('error_description');
if (errorCode === 'otp_expired' || (errorDescription && errorDescription.includes('expired'))) {
    // Clear the hash to prevent Supabase client confusion
    history.replaceState(null, '', window.location.pathname + window.location.search);
    // Redirect to login with explanation
    window.location.href = 'login.html?reason=magic_link_expired';
    return;
}
```

Place this AFTER the DOM element declarations (lines 6-53) but BEFORE `await Auth.init()` (line 110). Insert it right before the `// Initialize auth` comment on line 109.

**B) Expired session redirect (SECR-08) — replace "not logged in" block**

Replace the current not-logged-in handling (lines 113-117):
```javascript
if (!Auth.isLoggedIn()) {
    loadingState.style.display = 'none';
    notLoggedIn.style.display = 'block';
    return;
}
```

With a redirect to login.html with reason:
```javascript
if (!Auth.isLoggedIn()) {
    // If we got here via normal navigation (not a magic link error),
    // redirect to login with session_expired reason.
    // Don't redirect if the user just navigated here manually without a session —
    // check if there's evidence of a prior session (e.g., the page was reached
    // via a bookmark or direct URL, not a redirect from magic link).
    window.location.href = 'login.html?reason=session_expired';
    return;
}
```

**Important:** The `notLoggedIn` DOM element reference on line 7 (`document.getElementById('not-logged-in')`) can remain — it is harmless if unused, and removing it could break if other code references it. However, since we are redirecting instead of showing the not-logged-in div, the div itself in dashboard.html will never display. This is the correct behavior per SECR-08.

**Note about admin.js:** admin.js has its own completely separate auth flow with `checkAuth()` and `showLogin()` that shows an in-page admin login form. It does NOT use `Auth.init()`. The admin page's auth pattern is correct as-is — admins need to log in via the admin page itself, not be redirected to the general login page. No changes to admin.js.
  </action>
  <verify>
    <automated>grep -c "magic_link_expired\|session_expired\|otp_expired" js/dashboard.js</automated>
    Should return >= 3 (at least one occurrence of each string).
  </verify>
  <done>
    - dashboard.js checks URL hash for otp_expired error code BEFORE Auth.init()
    - Magic link reuse redirects to login.html?reason=magic_link_expired
    - Expired session (not logged in after Auth.init()) redirects to login.html?reason=session_expired
    - No changes to admin.js (its auth flow is separate and already correct)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add expired/reused reset link detection to reset-password.html and contextual messages to login.html</name>
  <files>reset-password.html, login.html</files>
  <action>
**A) reset-password.html — SECR-09: Detect expired/reused password reset link**

In the inline `<script>` block of `reset-password.html`, after `await Auth.init()` (currently line 275), add a session check to detect whether a valid password recovery session exists. If no session, the reset link was expired or already used.

After `await Auth.init();`, add:

```javascript
// Check if a valid recovery session exists (SECR-09)
// If no session after init, the reset link was expired or already used
const { data: { session: resetSession } } = await Auth.getClient().auth.getSession();
if (!resetSession) {
    // Hide the form and show clear expired message
    resetForm.style.display = 'none';
    showError('This password reset link has already been used or has expired.');

    // Add recovery path — link to request a new reset
    const recoveryLink = document.createElement('p');
    recoveryLink.style.textAlign = 'center';
    recoveryLink.style.marginTop = 'var(--space-md)';
    recoveryLink.innerHTML = '<a href="login.html">Go to login</a> to request a new password reset link.';
    document.querySelector('.reset-card').appendChild(recoveryLink);
    return;
}
```

Place this after `await Auth.init();` and before the closing `})();`. The existing form submission handler remains in place for valid sessions.

**B) login.html — SECR-08/SECR-10: Show contextual messages based on redirect reason**

In the inline `<script>` block of `login.html`, BEFORE the `await Auth.init();` call (currently line 566), add URL parameter reading and contextual message display:

```javascript
// Show contextual messages for auth edge case redirects (SECR-08, SECR-10)
const urlParams = new URLSearchParams(window.location.search);
const reason = urlParams.get('reason');
if (reason === 'session_expired') {
    showError('Your session has expired. Please sign in again.');
} else if (reason === 'magic_link_expired') {
    showError('That sign-in link has already been used. Please sign in with your password or request a new magic link.');
}
```

Place this AFTER the `showSuccess` function definition (line 483) and BEFORE the `// Sign In` comment (line 485). This ensures `showError` is defined before it's called.

**CRITICAL: CSP hash regeneration**

Modifying inline `<script>` blocks in `reset-password.html` and `login.html` will invalidate their existing CSP sha256 hashes. After making the code changes:

1. For each modified HTML file, extract the EXACT content of each inline `<script>` block (everything between `<script>` and `</script>` tags, preserving whitespace exactly)
2. Compute the SHA-256 hash of each inline script content
3. Base64-encode the hash
4. Update the `Content-Security-Policy` meta tag in the same file, replacing the old hash with the new one

Use this command to compute the hash for an inline script (replace the file and extract the script content):
```bash
# Extract inline script content and compute SHA-256 hash
# The hash must match exactly what the browser computes
echo -n '<script content here>' | openssl dgst -sha256 -binary | openssl base64
```

The CSP meta tag for each page contains multiple hashes (for all 27 pages' inline scripts). Only the hash for the MODIFIED file's inline script needs to change. The other hashes in the CSP are shared across all pages and remain valid.

**Important:** The CSP meta tags use the same set of hashes across all 27 pages (per the 05-02 decision). When you change an inline script in login.html or reset-password.html:
1. Compute the OLD hash of the script (before your change) to know which hash to replace
2. Compute the NEW hash of the script (after your change)
3. Replace the old hash with the new hash in ALL 27 HTML pages' CSP meta tags

This is critical — if the CSP hash is wrong, the inline script will be blocked by the browser and the page will break.

To update all 27 pages efficiently, use a find-and-replace across all HTML files to swap the old hash for the new hash.

**Note on escapeHtml for error messages:** The `reason` parameter value comes from our own code (hardcoded string in dashboard.js redirect), not from user input. It is safe to display via `showError()` which sets `textContent` (not `innerHTML`). The `showError` function in login.html uses `errorDiv.textContent = message`, which is inherently XSS-safe.
  </action>
  <verify>
    <automated>grep -c "reason.*session_expired\|reason.*magic_link_expired\|getSession.*resetSession\|link.*expired\|already been used" reset-password.html login.html</automated>
    Should return >= 4 (multiple matches across both files).
  </verify>
  <done>
    - reset-password.html checks getSession() after Auth.init() — if no session, hides form and shows "link expired" message with recovery link to login.html
    - login.html reads ?reason= query parameter and shows contextual error message for session_expired and magic_link_expired
    - CSP sha256 hashes updated in ALL 27 HTML pages for any modified inline script blocks
    - All error messages use textContent (XSS-safe), not innerHTML
  </done>
</task>

</tasks>

<verification>
- [ ] dashboard.js detects otp_expired in URL hash before Auth.init() and redirects to login.html?reason=magic_link_expired
- [ ] dashboard.js redirects to login.html?reason=session_expired when not logged in after Auth.init()
- [ ] reset-password.html checks for valid session after Auth.init() and shows "link expired" message if none
- [ ] reset-password.html hides the password form when link is expired
- [ ] reset-password.html shows a link to login.html for requesting a new reset
- [ ] login.html reads ?reason= param and displays contextual error messages
- [ ] CSP hashes updated in all 27 HTML pages for modified inline scripts
- [ ] No changes to admin.js (separate auth flow)
- [ ] grep for "error-message" or "text-muted" patterns confirms no leftover ad-hoc error strings
</verification>

<success_criteria>
Auth edge cases are handled gracefully:
1. Expired sessions redirect to login with a clear "session expired" message
2. Expired/reused password reset links show a clear error with a path to request a new one
3. Reused magic links redirect to login with a clear "link already used" message
4. No user is left on a broken/stuck page without explanation or recovery path
</success_criteria>

<output>
After completion, create `.planning/phases/06-auth-security/06-02-SUMMARY.md`
</output>
