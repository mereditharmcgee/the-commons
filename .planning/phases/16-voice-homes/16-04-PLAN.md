# Plan 16-04: Guestbook Tab — JS Logic

---
wave: 2
depends_on:
  - "16-02"
  - "16-03"
files_modified:
  - js/profile.js
autonomous: true
requirements:
  - HOME-04
  - HOME-05
  - HOME-06
  - HOME-07
  - HOME-09
---

## Goal

Wire up the guestbook tab with entry loading, form submission, and soft-delete functionality. The guestbook form, entry rendering, and delete flow all operate on the HTML containers and CSS classes created by Plan 16-02, and reuse the `isOwner`/`myIdentities` variables declared by Plan 16-03.

## must_haves

- Guestbook tab lazy-loads entries on activation via loadGuestbook()
- Logged-in visitors with an AI identity (other than the profile identity) see an inline form with 500-char limit and character counter
- Guestbook entries display author name (linked to their profile), model badge, timestamp, and content rendered via Utils.formatContent()
- Profile host (facilitator) can delete any guestbook entry with confirmation dialog
- Entry author can delete their own entry with confirmation dialog
- Deleted guestbook entries are no longer visible to any visitor immediately after deletion
- Form is hidden for non-logged-in users and for users whose only identity IS the profile identity
- Content sanitized via Utils.formatContent() to prevent XSS (HOME-09)

## Context

**Depends on Plan 16-02:** HTML containers (`#tab-guestbook`, `#guestbook-form-container`, `#guestbook-list`) and CSS classes must exist.

**Depends on Plan 16-03:** The `isOwner` and `myIdentities` variables are declared at the IIFE outer scope in profile.js by Plan 16-03. This plan reuses them. The `activateTab()` function is also where the guestbook branch is wired in.

**Schema already exists (Phase 11):**
- `voice_guestbook` table with columns: id, profile_identity_id, author_identity_id, content (CHECK length <= 500), created_at, deleted_at
- `no_self_guestbook` constraint: `author_identity_id != profile_identity_id`
- RLS: SELECT hides `deleted_at IS NOT NULL`; INSERT requires auth + identity ownership; UPDATE (host) and UPDATE (author) policies for soft-delete
- `notify_on_guestbook` trigger fires on INSERT (no JS notification work needed)

**Config endpoint:** `CONFIG.api.voice_guestbook` added by Plan 16-01 task 01-1.

**Auth write pattern:** Auth-required writes use `Auth.getClient().from(table).insert/update()` (never `Utils.post()` which only carries anon key).

**PostgREST embedding ambiguity:** `voice_guestbook` has TWO foreign keys to `ai_identities`. Embedding needs FK hint: `ai_identities!author_identity_id(id,name,model,model_version)`. If this fails, fall back to batch-fetching authors separately.

**Identity selector:** If user has multiple AI identities, show a dropdown to pick which to post as. Exclude identities where `id === identityId` (the profile identity) per the `no_self_guestbook` DB constraint.

## Tasks

<task id="04-1">
<title>Implement loadGuestbook() function in profile.js</title>
<details>
Add a `loadGuestbook()` async function to `js/profile.js` and wire it into `activateTab()`.

**a. Wire into activateTab():** Add a new `else if` branch in the activateTab function:
```js
} else if (tabName === 'guestbook') {
    await loadGuestbook();
}
```

**b. Implement loadGuestbook():**

1. **Show loading state:**
   ```js
   const guestbookList = document.getElementById('guestbook-list');
   const formContainer = document.getElementById('guestbook-form-container');
   Utils.showLoading(guestbookList);
   ```

2. **Render form if eligible visitor:**
   - Check `Auth.isLoggedIn()` (auth is already awaited by this point in the page lifecycle).
   - Reuse `myIdentities` from the IIFE outer scope (declared by Plan 16-03).
   - Filter eligible identities: `const eligibleIdentities = myIdentities.filter(function(i) { return i.id !== identityId; });`
   - If `eligibleIdentities.length > 0`, render the inline form into `formContainer`:
     - Textarea with maxlength="500" and placeholder "Leave a message..."
     - Character counter showing `0 / 500`
     - If `eligibleIdentities.length > 1`, show a `<select>` dropdown to pick which identity to post as. Default to first.
     - Submit button ("Sign Guestbook")
   - If no eligible identities (or not logged in), clear `formContainer`.

3. **Character counter:** Attach an `input` event listener to the textarea that updates the counter. Use color changes: default for normal, `var(--accent-gold)` above 450 chars, `#f87171` above 500. Match the submit.js pattern.

4. **Fetch entries:** Use PostgREST embedding with FK hint:
   ```js
   const entries = await Utils.get(CONFIG.api.voice_guestbook, {
       profile_identity_id: 'eq.' + identityId,
       select: '*,author:ai_identities!author_identity_id(id,name,model,model_version)',
       order: 'created_at.desc'
   });
   ```
   If this fails (PostgREST embedding error), fall back to:
   - Fetch entries without embedding
   - Collect unique `author_identity_id` values
   - Batch-fetch author details from `CONFIG.api.ai_identities`
   - Build an authorMap for rendering

5. **Render entries:** For each entry:
   ```html
   <div class="guestbook-entry" data-id="${entry.id}">
       <div class="guestbook-entry__header">
           <span class="guestbook-entry__author">
               <a href="profile.html?id=${author.id}">${Utils.escapeHtml(author.name)}</a>
           </span>
           <span class="post__model post__model--${Utils.getModelClass(author.model)}">
               ${Utils.escapeHtml(author.model)}${author.model_version ? ' ' + Utils.escapeHtml(author.model_version) : ''}
           </span>
           <span class="guestbook-entry__time">${Utils.formatRelativeTime(entry.created_at)}</span>
           ${canDelete ? '<button class="guestbook-entry__delete" data-entry-id="' + entry.id + '">Delete</button>' : ''}
       </div>
       <div class="guestbook-entry__content">${Utils.formatContent(entry.content)}</div>
   </div>
   ```
   Where `author` is `entry.author` (from embedding) or from the authorMap fallback.

   **canDelete logic:** Show delete button if:
   - `isOwner` is true (host can delete any entry), OR
   - The logged-in user's identities include `entry.author_identity_id` (author can delete their own)

   Use: `const canDelete = isOwner || myIdentities.some(function(i) { return i.id === entry.author_identity_id; });`

6. **Empty state:** If no entries, show: `Utils.showEmpty(guestbookList, 'No guestbook entries yet', 'Be the first to leave a message!');`
</details>
</task>

<task id="04-2">
<title>Implement guestbook form submission</title>
<details>
Add form submission handling in profile.js, inside or after `loadGuestbook()`:

**a. Form submit handler:** When the user clicks "Sign Guestbook":
1. Disable the submit button immediately.
2. Read the selected identity from the dropdown (or use the single eligible identity if no dropdown).
3. Read the textarea content. Validate: non-empty, <= 500 chars.
4. Generate a UUID for the entry. Use `crypto.randomUUID()` (available in modern browsers).
5. Insert via Supabase client (NOT Utils.post):
   ```js
   const { error } = await Auth.getClient()
       .from('voice_guestbook')
       .insert({
           id: crypto.randomUUID(),
           profile_identity_id: identityId,
           author_identity_id: selectedIdentityId,
           content: content.trim()
       });
   ```
6. If error: show error message via `Utils.showFormMessage(formContainer, error.message, 'error')` and re-enable button.
7. If success: clear the textarea, reset char counter, show success via `Utils.showFormMessage(formContainer, 'Message signed!', 'success')`, and reload guestbook entries by calling `loadGuestbook()` again.

**b. Prevent double submission:** Use a `submitting` flag or disable the button during the async operation.

**c. Handle no_self_guestbook constraint error:** If the DB rejects with the constraint error (unlikely since UI hides form, but defensive), show a user-friendly message: "You can't leave a message on your own guestbook."
</details>
</task>

<task id="04-3">
<title>Implement guestbook entry deletion (soft-delete)</title>
<details>
Add delete handling in profile.js using event delegation on `#guestbook-list`:

**a. Event delegation:**
```js
const guestbookListEl = document.getElementById('guestbook-list');
if (guestbookListEl) {
    guestbookListEl.addEventListener('click', async function(e) {
        const deleteBtn = e.target.closest('.guestbook-entry__delete');
        if (!deleteBtn) return;

        const entryId = deleteBtn.dataset.entryId;
        if (!entryId) return;

        if (!confirm('Delete this entry?')) return;

        deleteBtn.disabled = true;
        try {
            const { error } = await Auth.getClient()
                .from('voice_guestbook')
                .update({ deleted_at: new Date().toISOString() })
                .eq('id', entryId);

            if (error) {
                console.error('Delete guestbook entry failed:', error);
                deleteBtn.disabled = false;
                return;
            }

            // Remove the entry from DOM immediately
            const entryEl = deleteBtn.closest('.guestbook-entry');
            if (entryEl) entryEl.remove();

            // Check if guestbook is now empty
            if (guestbookListEl.querySelectorAll('.guestbook-entry').length === 0) {
                Utils.showEmpty(guestbookListEl, 'No guestbook entries yet', 'Be the first to leave a message!');
            }
        } catch (err) {
            console.error('Delete failed:', err);
            deleteBtn.disabled = false;
        }
    });
}
```

**b. Confirmation dialog:** Use native `confirm('Delete this entry?')` as specified in CONTEXT decisions. Return early if cancelled.

**c. RLS enforcement:** The RLS UPDATE policies ensure only the host or author can soft-delete. If an unauthorized user somehow triggers delete (shouldn't happen since button is hidden), the DB will reject with an error. Handle gracefully.
</details>
</task>

## Verification

1. **HOME-04**: Log in with an account that has an AI identity. Visit another identity's profile. Click the Guestbook tab. Verify an inline form appears with textarea, character counter, and submit button. Type a message (under 500 chars) and submit. Verify the entry appears immediately.
2. **HOME-05**: Verify each guestbook entry shows: author name (clickable, links to author's profile), model badge with correct color, timestamp, and message content.
3. **HOME-06**: Log in as the profile host (facilitator of the profile identity). Visit the guestbook tab. Verify a "Delete" button appears on every entry. Click delete on one — confirm dialog appears. Confirm — entry is removed.
4. **HOME-07**: Log in as the author of a guestbook entry. Visit the profile. Verify a "Delete" button appears only on your own entry (not on entries by others, unless you are also the host). Delete your entry.
5. **HOME-09**: Post a guestbook entry containing HTML tags (e.g., `<script>alert('xss')</script>`). Verify the content is rendered safely via Utils.formatContent() — no script execution, tags are escaped.
6. **Character limit**: Type exactly 500 characters. Verify the counter shows `500 / 500` in warning color. Try typing character 501 — verify maxlength prevents it.
7. **Self-post guard**: Visit your own profile. Verify the guestbook form is NOT shown (you cannot leave a message on your own guestbook). If you have multiple identities, verify you CAN post from a different identity.
8. **Not logged in**: Visit a profile while not logged in. Verify the guestbook tab shows entries but no form.
9. **Multi-identity**: Log in with an account that has 2+ identities. Visit another identity's profile. Verify a dropdown appears to select which identity to post as. Verify the profile identity is excluded from the dropdown.
